
// QUANT TRADING ALGO BOT (USING REGIME AND MEAN REVERSION)

#property strict

#include <Trade/Trade.mqh>
CTrade trade;

// INPUTS 
input double BaseRiskUSD     = 0.5;

input int    ATR_Fast        = 5;
input int    ATR_Slow        = 30;
input int    Lookback        = 30;

input double CompressRatio  = 0.6;
input double ExpandRatio    = 1.05;

input double SL_ATR         = 1.2;
input double TP_ATR_SLOW    = 3.0;

input double MaxSpreadATR   = 0.25;
input int    CooldownBars   = 3;

//Leverage Engine
input double MinLeverage    = 50;
input double BaseLeverage   = 80;
input double MaxLeverage   = 100;

// GLOBAL 
datetime last_bar = 0;
int bars_after_trade = 999;

int atrFastHandle;
int atrSlowHandle;

// INIT 
int OnInit()
{
   atrFastHandle = iATR(_Symbol, PERIOD_M1, ATR_Fast);
   atrSlowHandle = iATR(_Symbol, PERIOD_M1, ATR_Slow);

   if(atrFastHandle == INVALID_HANDLE || atrSlowHandle == INVALID_HANDLE)
   {
      Print("ATR handle init failed");
      return INIT_FAILED;
   }
   return INIT_SUCCEEDED;
}

// DEINIT 
void OnDeinit(const int reason)
{
   IndicatorRelease(atrFastHandle);
   IndicatorRelease(atrSlowHandle);
}

// ATR READ
double ReadATR(int handle)
{
   double buf[];
   if(CopyBuffer(handle, 0, 1, 1, buf) <= 0)
      return 0;
   return buf[0];
}

// ON TICK 
void OnTick()
{
   datetime t = iTime(_Symbol, PERIOD_M1, 0);
   if(t == last_bar)
      return;
   last_bar = t;

   bars_after_trade++;

   // One position only
   if(PositionSelect(_Symbol))
      return;

   if(bars_after_trade < CooldownBars)
      return;

   // ATR 
   double atr_fast = ReadATR(atrFastHandle);
   double atr_slow = ReadATR(atrSlowHandle);
   if(atr_fast <= 0 || atr_slow <= 0)
      return;

   double vol_ratio = atr_fast / atr_slow;

   if(vol_ratio < CompressRatio)
      return;

   // PRICE & SPREAD 
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double spread = ask - bid;

   if(spread > atr_slow * MaxSpreadATR)
      return;

   // STRUCTURE 
   int hi = iHighest(_Symbol, PERIOD_M1, MODE_HIGH, Lookback, 1);
   int lo = iLowest (_Symbol, PERIOD_M1, MODE_LOW , Lookback, 1);
   if(hi < 0 || lo < 0)
      return;

   double highL  = iHigh(_Symbol, PERIOD_M1, hi);
   double lowL   = iLow (_Symbol, PERIOD_M1, lo);
   double close1 = iClose(_Symbol, PERIOD_M1, 1);

   bool longSignal  = (close1 > highL - atr_fast * 0.2 && vol_ratio > ExpandRatio);
   bool shortSignal = (close1 < lowL  + atr_fast * 0.2 && vol_ratio > ExpandRatio);

   if(!longSignal && !shortSignal)
      return;

   // SL / TP 
   double sl_dist = atr_fast * SL_ATR;
   double tp_dist = atr_slow * TP_ATR_SLOW;

   double stopLevel = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL) * _Point;
   if(sl_dist < stopLevel || tp_dist < stopLevel)
      return;

   // RISK-BASED LOT
   double tickVal = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSz  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   if(tickVal <= 0 || tickSz <= 0)
      return;

   double loss_per_lot = sl_dist / tickSz * tickVal;
   if(loss_per_lot <= 0)
      return;

   double lot = BaseRiskUSD / loss_per_lot;

   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double step   = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);

   lot = MathFloor(lot / step) * step;
   lot = MathMax(minLot, MathMin(lot, maxLot));
   if(lot < minLot)
      return;

   // EXECUTION 
   trade.SetDeviationInPoints(20);

   bool ok;
   if(longSignal)
      ok = trade.Buy(lot, _Symbol, 0, ask - sl_dist, ask + tp_dist);
   else
      ok = trade.Sell(lot, _Symbol, 0, bid + sl_dist, bid - tp_dist);

   if(ok)
   {
      bars_after_trade = 0;
   }
   else
   {
      Print("Trade failed: ",
            trade.ResultRetcode(),
            " | ",
            trade.ResultComment());
   }
}
