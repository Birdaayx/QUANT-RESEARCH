
// SCALP QUANT â€“ REGIME ADAPTIVE

#property strict
#include <Trade/Trade.mqh>
CTrade trade;

// INPUTS 
input double RiskUSD        = 0.5;

input int    ATR_Fast       = 5;
input int    ATR_Slow       = 30;
input int    Lookback       = 15;

input double SL_ATR_Base    = 1.2;
input double TP_ATR_Base    = 1.8;

input double MaxSpreadATR  = 0.6;
input int    CooldownBars  = 2;

// GLOBAL 
datetime last_bar = 0;
int bars_after_trade = 999;

int atrFastHandle, atrSlowHandle;

// HMM 
#define N_STATE 3
#define N_OBS   2
// 0=Compression | 1=Transition | 2=Expansion

double HMM_A[N_STATE][N_STATE] =
{
   {0.80, 0.20, 0.00},
   {0.15, 0.70, 0.15},
   {0.05, 0.30, 0.65}
};

double HMM_MU[N_STATE][N_OBS] =
{
   {0.0, 0.7},
   {0.0, 1.0},
   {0.0, 1.4}
};

double HMM_VAR[N_STATE][N_OBS] =
{
   {1e-6, 0.10},
   {1e-6, 0.20},
   {1e-6, 0.35}
};

double log_alpha[N_STATE];

// INIT 
int OnInit()
{
   atrFastHandle = iATR(_Symbol, PERIOD_M5, ATR_Fast);
   atrSlowHandle = iATR(_Symbol, PERIOD_M5, ATR_Slow);
   if(atrFastHandle == INVALID_HANDLE || atrSlowHandle == INVALID_HANDLE)
      return INIT_FAILED;

   for(int i=0;i<N_STATE;i++)
      log_alpha[i] = MathLog(1.0 / N_STATE);

   return INIT_SUCCEEDED;
}

void OnDeinit(const int reason)
{
   IndicatorRelease(atrFastHandle);
   IndicatorRelease(atrSlowHandle);
}

// HELPERS 
double ReadATR(int handle)
{
   double buf[1];
   if(CopyBuffer(handle,0,1,1,buf)<=0) return 0;
   return buf[0];
}

double LogGaussian(double x,double mu,double var)
{
   if(var <= 0) return -1e10;
   return -0.5 * (MathLog(2.0*M_PI*var)
          + (x-mu)*(x-mu)/var);
}

double LogEmission(int state,const double &obs[])
{
   double logp = 0.0;
   for(int i=0;i<N_OBS;i++)
      logp += LogGaussian(obs[i], HMM_MU[state][i], HMM_VAR[state][i]);
   return logp;
}

void HMM_Update(const double &obs[])
{
   double next_log_alpha[N_STATE];

   for(int j=0;j<N_STATE;j++)
   {
      double maxv = -1e100;
      for(int i=0;i<N_STATE;i++)
         maxv = MathMax(maxv, log_alpha[i] + MathLog(HMM_A[i][j]));

      double sum = 0.0;
      for(int i=0;i<N_STATE;i++)
         sum += MathExp(log_alpha[i] + MathLog(HMM_A[i][j]) - maxv);

      next_log_alpha[j] = maxv + MathLog(sum) + LogEmission(j,obs);
   }

   double max_all = next_log_alpha[0];
   for(int i=1;i<N_STATE;i++)
      max_all = MathMax(max_all,next_log_alpha[i]);

   double norm = 0.0;
   for(int i=0;i<N_STATE;i++)
      norm += MathExp(next_log_alpha[i]-max_all);

   for(int i=0;i<N_STATE;i++)
      log_alpha[i] = next_log_alpha[i] - (max_all + MathLog(norm));
}

int HMM_State()
{
   int best = 0;
   for(int i=1;i<N_STATE;i++)
      if(log_alpha[i] > log_alpha[best]) best = i;
   return best;
}

// MAIN 
void OnTick()
{
   datetime t = iTime(_Symbol, PERIOD_M5, 0);
   if(t == last_bar) return;
   last_bar = t;

   bars_after_trade++;
   if(PositionSelect(_Symbol)) return;
   if(bars_after_trade < CooldownBars) return;

   double atrF = ReadATR(atrFastHandle);
   double atrS = ReadATR(atrSlowHandle);
   if(atrF<=0 || atrS<=0) return;

   double vol_ratio = atrF / atrS;

   double c1 = iClose(_Symbol, PERIOD_M5, 1);
   double c2 = iClose(_Symbol, PERIOD_M5, 2);
   if(c1<=0 || c2<=0) return;

   double obs[N_OBS];
   obs[0] = MathLog(c1/c2);
   obs[1] = vol_ratio;
   HMM_Update(obs);

   int regime = HMM_State();

   double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);
   if((ask-bid) > atrS * MaxSpreadATR) return;

   int hi = iHighest(_Symbol,PERIOD_M5,MODE_HIGH,Lookback,1);
   int lo = iLowest (_Symbol,PERIOD_M5,MODE_LOW ,Lookback,1);
   if(hi<0 || lo<0) return;

   bool up   = c1 > iHigh(_Symbol,PERIOD_M5,hi);
   bool down = c1 < iLow (_Symbol,PERIOD_M5,lo);
   if(!up && !down) return;

   // REGIME ADAPTIVE RISK 
   double sl_mult = SL_ATR_Base;
   double tp_mult = TP_ATR_Base;
   double riskAdj = 1.0;

   if(regime == 2) {        // Expansion
      tp_mult *= 0.7;
      sl_mult *= 0.9;
      riskAdj = 0.7;
   }
   else if(regime == 0) {   // Compression
      tp_mult *= 1.2;
}

   // Management 
   double sl = atrF * sl_mult;
   double tp = atrF * tp_mult;

   double tickVal = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
   double tickSz  = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);
   
   //  tickVal = 0
   if(tickVal == 0) tickVal = 1; 
   if(tickSz == 0) tickSz = 0.01;

   double loss_per_lot = (sl / tickSz) * tickVal;
   if(loss_per_lot == 0) loss_per_lot = 100; // Fallback

   // Lot theo Risk
   double lot = (RiskUSD * riskAdj) / loss_per_lot;

   double minLot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MAX);
   double step   = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);

   lot = MathFloor(lot/step)*step;
   lot = MathMax(minLot,MathMin(lot,maxLot));
   
 if(lot < minLot) return;

   // EXECUTION
   trade.SetDeviationInPoints(20);
   bool ok;

   if(up)
      ok = trade.Buy(lot,_Symbol,ask,ask-sl,ask+tp);
   else
      ok = trade.Sell(lot,_Symbol,bid,bid+sl,bid-tp);

   if(ok)
      bars_after_trade = 0;

   PrintFormat("SCALP | Regime=%d vol=%.2f lot=%.2f",
               regime, vol_ratio, lot);
}
