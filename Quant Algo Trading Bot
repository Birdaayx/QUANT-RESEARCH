
// XAU QUANT â€“ REGIME AWARE WITH LOG-HMM 

#property strict
#include <Trade/Trade.mqh>
CTrade trade;

// INPUTS
input double RiskUSD        = 0.5;

input int    ATR_Fast       = 5;
input int    ATR_Slow       = 30;
input int    Lookback       = 20;

input double CompressRatio  = 0.75;
input double ExpandRatio    = 1.15;

input double SL_ATR         = 1.5;
input double TP_ATR         = 3.5;

input double MaxSpreadATR  = 0.25;
input int    CooldownBars  = 4;

// GLOBAL 
datetime last_bar = 0;
int bars_after_trade = 999;

int atrFastHandle;
int atrSlowHandle;

// Hidden Markov 
#define N_STATE 3
#define N_OBS   2
// State: 0 = Compression, 1 = Transition, 2 = Expansion

double HMM_A[N_STATE][N_STATE] =
{
   {0.90, 0.10, 0.00},
   {0.05, 0.85, 0.10},
   {0.00, 0.15, 0.85}
};

double HMM_MU[N_STATE][N_OBS] =
{
   {0.0, 0.6},
   {0.0, 1.0},
   {0.0, 1.8}
};

double HMM_VAR[N_STATE][N_OBS] =
{
   {1e-6, 0.05},
   {1e-6, 0.10},
   {1e-6, 0.25}
};

// log-alpha (filtering probability)
double log_alpha[N_STATE];

// INIT
int OnInit()
{
   atrFastHandle = iATR(_Symbol, PERIOD_M5, ATR_Fast);
   atrSlowHandle = iATR(_Symbol, PERIOD_M5, ATR_Slow);

   if(atrFastHandle == INVALID_HANDLE || atrSlowHandle == INVALID_HANDLE)
      return INIT_FAILED;

   // Uniform prior (log)
   for(int i=0;i<N_STATE;i++)
      log_alpha[i] = MathLog(1.0 / N_STATE);

   return INIT_SUCCEEDED;
}

void OnDeinit(const int reason)
{
   IndicatorRelease(atrFastHandle);
   IndicatorRelease(atrSlowHandle);
}

// HELPERS 
double ReadATR(int handle)
{
   double buf[1];
   if(CopyBuffer(handle,0,1,1,buf)<=0) return 0;
   return buf[0];
}

// Log Gaussian PDF
double LogGaussian(double x,double mu,double var)
{
   if(var <= 0) return -1e10;
   return -0.5 * (MathLog(2.0*M_PI*var)
          + (x-mu)*(x-mu)/var);
}

// Log emission probability
double LogEmission(int state,const double &obs[])
{
   double logp = 0.0;
   for(int i=0;i<N_OBS;i++)
      logp += LogGaussian(obs[i],
                          HMM_MU[state][i],
                          HMM_VAR[state][i]);
   return logp;
}

// HMM LOG-SPACE
void HMM_Update(const double &obs[])
{
   double next_log_alpha[N_STATE];

   for(int j=0;j<N_STATE;j++)
   {
      double maxv = -1e100;
      for(int i=0;i<N_STATE;i++)
         maxv = MathMax(maxv,
               log_alpha[i] + MathLog(HMM_A[i][j]));

      double sum = 0.0;
      for(int i=0;i<N_STATE;i++)
         sum += MathExp(log_alpha[i]
               + MathLog(HMM_A[i][j]) - maxv);

      next_log_alpha[j] =
         maxv + MathLog(sum) + LogEmission(j,obs);
   }

   // Normalize
   double max_all = next_log_alpha[0];
   for(int i=1;i<N_STATE;i++)
      max_all = MathMax(max_all,next_log_alpha[i]);

   double norm = 0.0;
   for(int i=0;i<N_STATE;i++)
      norm += MathExp(next_log_alpha[i]-max_all);

   for(int i=0;i<N_STATE;i++)
      log_alpha[i] =
         next_log_alpha[i] - (max_all + MathLog(norm));
}

// Argmax regime
int HMM_State()
{
   int best = 0;
   for(int i=1;i<N_STATE;i++)
      if(log_alpha[i] > log_alpha[best])
         best = i;
   return best;
}

// MAIN LOOP
void OnTick()
{
   datetime t = iTime(_Symbol, PERIOD_M5, 0);
   if(t == last_bar) return;
   last_bar = t;

   bars_after_trade++;

   if(PositionSelect(_Symbol)) return;
   if(bars_after_trade < CooldownBars) return;

   // ATR
   double atrF = ReadATR(atrFastHandle);
   double atrS = ReadATR(atrSlowHandle);
   if(atrF<=0 || atrS<=0) return;

   double vol_ratio = atrF / atrS;

   // Observation
   double c1 = iClose(_Symbol, PERIOD_M5, 1);
   double c2 = iClose(_Symbol, PERIOD_M5, 2);
   if(c1<=0 || c2<=0) return;

   double obs[N_OBS];
   obs[0] = MathLog(c1/c2);
   obs[1] = vol_ratio;

   // HMM filter
   HMM_Update(obs);
   int regime = HMM_State();

   // REGIME FILTER 
   if(vol_ratio > ExpandRatio) return;
   if(regime == 2) return;           // expansion filtered
   if(vol_ratio > CompressRatio) return;
   if(regime != 0) return;           // only compression

   // SPREAD FILTER 
   double ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
   double bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);
   if(ask<=0 || bid<=0) return;

   if((ask-bid) > atrS*MaxSpreadATR) return;

   // STRUCTURE BREAKOUT
   int hi = iHighest(_Symbol,PERIOD_M5,MODE_HIGH,Lookback,1);
   int lo = iLowest (_Symbol,PERIOD_M5,MODE_LOW ,Lookback,1);
   if(hi<0 || lo<0) return;

   double high = iHigh(_Symbol,PERIOD_M5,hi);
   double low  = iLow (_Symbol,PERIOD_M5,lo);

   bool up   = c1 > high;
   bool down = c1 < low;
   if(!up && !down) return;

   // SL/TP 
   double sl = atrF*SL_ATR;
   double tp = atrS*TP_ATR;

   double tickVal = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_VALUE);
   double tickSz  = SymbolInfoDouble(_Symbol,SYMBOL_TRADE_TICK_SIZE);
   if(tickVal<=0 || tickSz<=0) return;

   double loss_per_lot = sl/tickSz*tickVal;
   if(loss_per_lot<=0) return;

   double lot = RiskUSD/loss_per_lot;

   double minLot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MAX);
   double step   = SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);

   lot = MathFloor(lot/step)*step;
   lot = MathMax(minLot,MathMin(lot,maxLot));
   if(lot<minLot) return;

   // EXECUTION 
   trade.SetDeviationInPoints(20);

   bool ok;
   if(up)
      ok = trade.Buy(lot,_Symbol,ask,ask-sl,ask+tp);
   else
      ok = trade.Sell(lot,_Symbol,bid,bid+sl,bid-tp);

   if(ok) bars_after_trade = 0;
}
